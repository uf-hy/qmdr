# PR Reviewer - Codex å®¡æŸ¥ï¼›æœ‰é—®é¢˜å›ä¼ åˆ° Issue è§¦å‘ä¸‹ä¸€è½®ä¿®å¤ï¼ˆæœ€å¤š 5 è½®ï¼‰
# Rationale for triggers/tokens: docs/ci.md
name: PR Reviewer (Codex)

on:
  pull_request_target:
    types: [opened, synchronize, reopened, labeled, head_ref_force_pushed]

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: pr-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  review:
    runs-on: ubuntu-latest
    # åªå®¡æŸ¥æœ¬ä»“åº“å†…åˆ†æ”¯ + ä¸”å¸¦ auto-pr æ ‡ç­¾çš„ PRï¼ˆé¿å… fork æ³¨å…¥é£é™©ï¼‰
    if: |
      github.event.pull_request.head.repo.full_name == github.repository &&
      contains(github.event.pull_request.labels.*.name, 'auto-pr')

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Download PR diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_API_URL: ${{ github.event.pull_request.url }}
        run: |
          set -euo pipefail
          # ç”¨ GitHub API ç›´æ¥æ‹¿ diffï¼Œé¿å… checkout æ·±åº¦/merge-base å‘
          if ! curl -fsSL \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3.diff" \
            "$PR_API_URL" > /tmp/pr.diff; then
            echo "[WARN] Failed to download PR diff from $PR_API_URL" > /tmp/pr.diff
          fi
          wc -l /tmp/pr.diff

      - name: Install Codex CLI
        run: npm install -g @openai/codex

      - name: Get previous review feedback (if any)
        id: prev_review
        uses: actions/github-script@v7
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const body = (pr.body || '');
            const m = body.match(/Closes\s+#(\d+)/i);
            if (!m) {
              core.info('PR body has no Closes #<issue>, skip fetching previous review');
              core.setOutput('has_prev', 'false');
              core.setOutput('prev_text', '');
              return;
            }
            const issue_number = Number(m[1]);

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              per_page: 100,
            });

            // æ‰¾æœ€æ–°çš„ AI_PR_REVIEW_FEEDBACK è¯„è®º
            const marker = '<!-- AI_PR_REVIEW_FEEDBACK -->';
            const prevComments = comments
              .filter(c => (c.body || '').includes(marker))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            if (prevComments.length === 0) {
              core.info('No previous AI review found');
              core.setOutput('has_prev', 'false');
              core.setOutput('prev_text', '');
            } else {
              const prev = prevComments[0].body;
              // æå– blocking éƒ¨åˆ†
              const blockingMatch = prev.match(/Blocking:\n([\s\S]*?)(?=\n\n|\nSuggestions:|$)/);
              const blockingText = blockingMatch ? blockingMatch[1].trim() : '';
              core.setOutput('has_prev', 'true');
              core.setOutput('prev_blocking', blockingText);
              core.setOutput('prev_full', prev);
              core.info(`Found previous review with ${blockingText.split('\n').filter(l=>l.startsWith('-')).length} blocking items`);
            }

      - name: Run Codex Review (structured JSON, with context)
        id: codex_run
        env:
          CUSTOM_OPENAI_KEY: ${{ secrets.OPENAI_API_KEY }}
          HAS_PREV: ${{ steps.prev_review.outputs.has_prev }}
          PREV_BLOCKING: ${{ steps.prev_review.outputs.prev_blocking }}
        run: |
          set -euo pipefail

          cat > /tmp/review_schema.json <<'JSON'
          {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "verdict": {"type": "string", "enum": ["APPROVE", "REQUEST_CHANGES"]},
              "summary": {"type": "array", "items": {"type": "string"}},
              "blocking": {"type": "array", "items": {"type": "string"}},
              "suggestions": {"type": "array", "items": {"type": "string"}},
              "prev_blocking_checked": {"type": "array", "items": {"type": "string"}}
            },
            "required": ["verdict", "summary", "blocking", "suggestions", "prev_blocking_checked"]
          }
          JSON

          # åŠ¨æ€ç”Ÿæˆ promptï¼ŒåŒ…å«ä¸Šæ¬¡çš„ blocking é—®é¢˜
          cat > /tmp/review_prompt.txt <<'PROMPT'
          ä½ æ˜¯è¿™ä¸ª PR çš„ Reviewerã€‚

          åªåšä»£ç å®¡æŸ¥ï¼Œä¸è¦ä¿®æ”¹ä»»ä½•æ–‡ä»¶ï¼Œä¸è¦è¿è¡Œä»»ä½•ä¼šæ”¹åŠ¨ä»“åº“çš„å‘½ä»¤ã€‚
          è¯·é˜…è¯» diff æ–‡ä»¶ï¼š/tmp/pr.diffï¼Œç„¶åç»™å‡ºç»“æ„åŒ–ç»“è®ºã€‚

          è§„åˆ™ï¼ˆè¯·â€œå®½æ¾ä½†ä¸æ”¾æ°´â€ï¼Œé¿å…æ­»çŠŸï¼‰ï¼š
          
          ã€é˜»å¡é¡¹ï¼ˆblockingï¼‰åªå…è®¸å†™ P0 çº§åˆ«çš„é—®é¢˜ã€‘â€”â€”æ»¡è¶³ä»»ä¸€æ¡æ‰å¯ REQUEST_CHANGESï¼š
          - ä¼šå¯¼è‡´ CI / bun test å¤±è´¥ã€ç±»å‹/æ„å»ºå¤±è´¥
          - æ˜ç¡®çš„è¿è¡Œæ—¶å´©æºƒï¼šå¸¸è§å‘½ä»¤ï¼ˆå¦‚ qmd --help/status/search/query/embed/vsearchï¼‰åœ¨åˆç†é»˜è®¤é…ç½®ä¸‹ä¼šç›´æ¥å´©
          - æ˜ç¡®çš„å®‰å…¨é—®é¢˜ï¼ˆè¶Šæƒ/æ³¨å…¥/æ•æ„Ÿä¿¡æ¯æ³„éœ²ç­‰ï¼‰
          - æ˜ç¡®è¿åæœ¬ PR çš„ç›®æ ‡ï¼ˆä¾‹å¦‚â€œç§»é™¤æœ¬åœ° LLMâ€ä½†ä»æ®‹ç•™æœ¬åœ°ä¾èµ–è·¯å¾„ï¼‰
          
          ã€é P0 çš„é—®é¢˜ä¸€å¾‹æ”¾ suggestionsã€‘åŒ…æ‹¬ä½†ä¸é™äºï¼šæ¥å£è¯­ä¹‰åå¥½ã€æ–‡æ¡ˆã€ç»“æ„/é‡æ„å»ºè®®ã€å¯é€‰ä¼˜åŒ–ã€é¢å¤–æµ‹è¯•å»ºè®®ã€ç ´åæ€§å˜æ›´çš„â€œæ˜¯å¦éœ€è¦è¿ç§»è¯´æ˜â€ï¼ˆé™¤éä¼šå¯¼è‡´ç”¨æˆ·æ— æ³•è¿è¡ŒåŸºæœ¬å‘½ä»¤æˆ–æµ‹è¯•å¤±è´¥ï¼‰ã€‚
          
          - å¦‚æœä¸ç¡®å®šæˆ–ç½®ä¿¡åº¦ä¸é«˜ï¼šä¸è¦ blockingï¼Œæ”¾ suggestionsã€‚
          - å¤šè½®ä¿®å¤åœºæ™¯ï¼šè‹¥ä¸Šæ¬¡ blocking å·²å…¨éƒ¨ä¿®å¤ï¼Œä¸”æœ¬è½®æœªå¼•å…¥æ–°çš„ P0ï¼Œè¯·ç›´æ¥ verdict=APPROVEã€‚
          - summary ç”¨ 1-3 æ¡æ¦‚æ‹¬æœ¬ PR åšäº†ä»€ä¹ˆã€‚
          - suggestions å†™å¯é€‰æ”¹è¿›ï¼ˆä¸å¼ºåˆ¶ï¼‰ã€‚
          PROMPT

          # å¦‚æœæœ‰ä¸Šæ¬¡çš„ blocking é—®é¢˜ï¼Œè¿½åŠ åˆ° prompt
          if [ "$HAS_PREV" = "true" ] && [ -n "$PREV_BLOCKING" ]; then
            cat >> /tmp/review_prompt.txt <<CONTEXT

          === ä¸Šæ¬¡ Review çš„ Blocking é—®é¢˜ï¼ˆè¯·æ£€æŸ¥æ˜¯å¦å·²ä¿®å¤ï¼‰===
          $PREV_BLOCKING

          è¯·åœ¨ prev_blocking_checked æ•°ç»„ä¸­é€é¡¹è¯´æ˜æ¯ä¸ªé—®é¢˜çš„æ£€æŸ¥çŠ¶æ€ï¼š
          - å¦‚æœå·²ä¿®å¤ï¼Œå†™ "âœ… Fixed: <é—®é¢˜æè¿°>"
          - å¦‚æœä»ç„¶å­˜åœ¨ï¼Œå†™ "âŒ Still present: <é—®é¢˜æè¿°>"
          - å¦‚æœéƒ¨åˆ†ä¿®å¤ï¼Œå†™ "âš ï¸ Partially fixed: <é—®é¢˜æè¿°>"
          CONTEXT
          fi

          # ç”¨ codex exec + output schema å¼ºåˆ¶äº§å‡ºæœºå™¨å¯è§£æç»“æœ
          codex \
            -c 'model_providers.custom_openai.name="Custom OpenAI"' \
            -c 'model_providers.custom_openai.base_url="${{ secrets.OPENAI_BASE_URL }}"' \
            -c 'model_providers.custom_openai.env_key="CUSTOM_OPENAI_KEY"' \
            -c 'model_provider="custom_openai"' \
            -a on-failure \
            exec \
            --sandbox read-only \
            --output-schema /tmp/review_schema.json \
            --output-last-message /tmp/review_out.json \
            -m gpt-5.3-codex \
            - < /tmp/review_prompt.txt

          python3 - <<'PY'
          import json
          from pathlib import Path

          data = json.loads(Path('/tmp/review_out.json').read_text('utf-8'))
          verdict = data['verdict']

          md = []
          md.append(f"VERDICT: {verdict}")
          md.append("")
          md.append("Summary:")
          for x in data['summary']:
            md.append(f"- {x}")
          md.append("")

          # å¦‚æœæœ‰ä¸Šæ¬¡ blocking æ£€æŸ¥ï¼Œå…ˆæ˜¾ç¤ºè¿™ä¸ª
          if data.get('prev_blocking_checked'):
            md.append("=== ä¸Šæ¬¡ Blocking é—®é¢˜æ£€æŸ¥ ===")
            for x in data['prev_blocking_checked']:
              md.append(f"- {x}")
            md.append("")

          md.append("Blocking:")
          if data['blocking']:
            for x in data['blocking']:
              md.append(f"- {x}")
          else:
            md.append("- None")
          md.append("")
          md.append("Suggestions:")
          if data['suggestions']:
            for x in data['suggestions']:
              md.append(f"- {x}")
          else:
            md.append("- None")

          Path('/tmp/review.md').write_text("\n".join(md), encoding='utf-8')
          print(verdict)
          PY

      - name: Parse Codex output
        id: codex
        run: |
          VERDICT=$(python3 -c 'import json; print(json.load(open("/tmp/review_out.json"))["verdict"])')
          echo "verdict=$VERDICT" >> $GITHUB_OUTPUT
          cp /tmp/review.md "$RUNNER_TEMP/review.md"
          echo "review_path=$RUNNER_TEMP/review.md" >> $GITHUB_OUTPUT

      - name: Submit PR review (as GITHUB_TOKEN)
        if: github.event.pull_request.user.login != 'github-actions[bot]'
        uses: actions/github-script@v7
        env:
          REVIEW_PATH: ${{ steps.codex.outputs.review_path }}
          VERDICT: ${{ steps.codex.outputs.verdict }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const pr = context.payload.pull_request;
            const verdict = (process.env.VERDICT || '').trim().toUpperCase();
            const reviewPath = process.env.REVIEW_PATH;
            const body = reviewPath && fs.existsSync(reviewPath)
              ? fs.readFileSync(reviewPath, 'utf8')
              : '(no review text)';

            const event = verdict === 'APPROVE' ? 'APPROVE' : 'REQUEST_CHANGES';

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              event,
              body,
            });

      - name: Submit PR review (as PAT for bot-authored PR)
        if: github.event.pull_request.user.login == 'github-actions[bot]'
        uses: actions/github-script@v7
        env:
          REVIEW_PATH: ${{ steps.codex.outputs.review_path }}
          VERDICT: ${{ steps.codex.outputs.verdict }}
        with:
          github-token: ${{ secrets.PAT }}
          script: |
            const fs = require('fs');
            const pr = context.payload.pull_request;
            const verdict = (process.env.VERDICT || '').trim().toUpperCase();
            const reviewPath = process.env.REVIEW_PATH;
            const body = reviewPath && fs.existsSync(reviewPath)
              ? fs.readFileSync(reviewPath, 'utf8')
              : '(no review text)';

            const event = verdict === 'APPROVE' ? 'APPROVE' : 'REQUEST_CHANGES';

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              event,
              body,
            });

      - name: Notify Telegram (review result)
        continue-on-error: true
        env:
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
          VERDICT: ${{ steps.codex.outputs.verdict }}
          PR_NUM: ${{ github.event.pull_request.number }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          if [ -z "$TG_BOT_TOKEN" ] || [ -z "$TG_CHAT_ID" ]; then
            exit 0
          fi
          ISSUE_NUM=$(echo "$PR_BODY" | grep -oP 'Closes #\K\d+' | head -1)
          PR_URL="${{ github.server_url }}/${{ github.repository }}/pull/${PR_NUM}"
          if [ "$VERDICT" = "APPROVE" ]; then
            TITLE="âœ… [Revieweré€šè¿‡] PR #${PR_NUM}"
          else
            TITLE="ğŸ› ï¸ [Reviewerè¦æ±‚ä¿®æ”¹] PR #${PR_NUM}"
          fi
          TEXT="${TITLE}\n${PR_URL}\nIssue: #${ISSUE_NUM}"
          curl -fsS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage" \
            -d chat_id="$TG_CHAT_ID" \
            --data-urlencode text="$TEXT" \
            -d disable_web_page_preview=true >/dev/null || true

      - name: Send feedback back to Issue (max 5 rounds)
        if: ${{ steps.codex.outputs.verdict == 'REQUEST_CHANGES' }}
        uses: actions/github-script@v7
        env:
          REVIEW_PATH: ${{ steps.codex.outputs.review_path }}
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        with:
          # ç”¨ PAT è§¦å‘ issues:labeled å·¥ä½œæµï¼Œé¿å… GitHub é˜²é€’å½’æœºåˆ¶åäº‹ä»¶
          github-token: ${{ secrets.PAT }}
          script: |
            const fs = require('fs');
            const pr = context.payload.pull_request;
            const body = (pr.body || '');
            const m = body.match(/Closes\s+#(\d+)/i);
            if (!m) {
              core.warning('PR body has no Closes #<issue>, skip sending feedback');
              return;
            }
            const issue_number = Number(m[1]);

            const marker = '<!-- AI_PR_REVIEW_FEEDBACK -->';
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              per_page: 100,
            });
            const rounds = comments.filter(c => (c.body || '').includes(marker)).length;
            const nextRound = rounds + 1;

            if (nextRound > 5) {
              const stopMsg = `${marker}\nâš ï¸ PR Reviewer: å·²è¾¾åˆ°æœ€å¤§å›åˆæ•° 5ï¼Œåœæ­¢è‡ªåŠ¨å¾€è¿”ã€‚\nè¯·ä¸»äººæ‰‹åŠ¨ä»‹å…¥ï¼š${pr.html_url}`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number,
                body: stopMsg
              });

              // å…³é”®èŠ‚ç‚¹è¯¦ç»†é€šçŸ¥ï¼ˆè¶…è¿‡ 5 è½®ï¼‰
              const tgToken = process.env.TG_BOT_TOKEN || '';
              const tgChat = process.env.TG_CHAT_ID || '';
              if (tgToken && tgChat) {
                const tgText = [
                  'âš ï¸ [è‡ªåŠ¨æµç¨‹åœæ­¢ï¼šè¶…è¿‡5è½®]',
                  `PR #${pr.number}: ${pr.html_url}`,
                  `Issue #${issue_number}`,
                  'è¯·æ‰‹åŠ¨ä»‹å…¥å¤„ç†ã€‚'
                ].join('\n');
                await fetch(`https://api.telegram.org/bot${tgToken}/sendMessage`, {
                  method: 'POST',
                  headers: {'content-type': 'application/x-www-form-urlencoded'},
                  body: new URLSearchParams({chat_id: tgChat, text: tgText, disable_web_page_preview: 'true'})
                });
              }
              return;
            }

            const reviewPath = process.env.REVIEW_PATH;
            const reviewText = reviewPath && fs.existsSync(reviewPath)
              ? fs.readFileSync(reviewPath, 'utf8')
              : '(no review text)';

            const commentBody = [
              marker,
              `### ğŸ” PR Reviewer åé¦ˆï¼ˆç¬¬ ${nextRound}/5 è½®ï¼‰`,
              `æ¥æº PR: #${pr.number} ${pr.html_url}`,
              '',
              reviewText,
              '',
              'è¯· Issue Handler æ ¹æ®ä»¥ä¸Š Blocking/Suggestions ä¿®å¤åå†æ¨æ–°æäº¤ã€‚'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              body: commentBody,
            });

            // é‡æ–°è§¦å‘ Issue handlerï¼štoggle auto-work label
            const labels = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              per_page: 100,
            });
            const has = labels.data.some(l => l.name === 'auto-work');
            if (has) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number,
                name: 'auto-work',
              });
            }
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              labels: ['auto-work'],
            });
