# PR Reviewer â€” Codex å®¡æŸ¥ï¼›æœ‰é—®é¢˜å›ä¼ åˆ° Issue è§¦å‘ä¸‹ä¸€è½®ä¿®å¤ï¼ˆæœ€å¤š 5 è½®ï¼‰
name: PR Reviewer (Codex)

on:
  pull_request_target:
    types: [opened, synchronize, reopened, labeled]

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: pr-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  review:
    runs-on: ubuntu-latest
    # åªå®¡æŸ¥æœ¬ä»“åº“å†…åˆ†æ”¯ + ä¸”å¸¦ auto-pr æ ‡ç­¾çš„ PRï¼ˆé¿å… fork æ³¨å…¥é£é™©ï¼‰
    if: |
      github.event.pull_request.head.repo.full_name == github.repository &&
      contains(github.event.pull_request.labels.*.name, 'auto-pr')

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Install Codex CLI
        run: npm install -g @openai/codex

      - name: Download PR diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_API_URL: ${{ github.event.pull_request.url }}
        run: |
          # ç”¨ GitHub API ç›´æ¥æ‹¿ diffï¼Œé¿å… checkout æ·±åº¦/merge-base å‘
          curl -fsSL \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3.diff" \
            "$PR_API_URL" > /tmp/pr.diff
          wc -l /tmp/pr.diff

      - name: Run Codex Review (structured JSON)
        id: codex
        env:
          CUSTOM_OPENAI_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail

          cat > /tmp/review_schema.json <<'JSON'
          {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "verdict": {"type": "string", "enum": ["APPROVE", "REQUEST_CHANGES"]},
              "summary": {"type": "array", "items": {"type": "string"}},
              "blocking": {"type": "array", "items": {"type": "string"}},
              "suggestions": {"type": "array", "items": {"type": "string"}}
            },
            "required": ["verdict", "summary", "blocking", "suggestions"]
          }
          JSON

          cat > /tmp/review_prompt.txt <<'PROMPT'
          ä½ æ˜¯è¿™ä¸ª PR çš„ Reviewerã€‚

          åªåšä»£ç å®¡æŸ¥ï¼Œä¸è¦ä¿®æ”¹ä»»ä½•æ–‡ä»¶ï¼Œä¸è¦è¿è¡Œä»»ä½•ä¼šæ”¹åŠ¨ä»“åº“çš„å‘½ä»¤ã€‚
          è¯·é˜…è¯» diff æ–‡ä»¶ï¼š/tmp/pr.diffï¼Œç„¶åç»™å‡ºç»“æ„åŒ–ç»“è®ºã€‚

          è§„åˆ™ï¼š
          - å¦‚æœå­˜åœ¨å¿…é¡»ä¿®å¤çš„é—®é¢˜ï¼ˆä¼šå¯¼è‡´ bugã€æµ‹è¯•å¤±è´¥ã€ç ´åå…¼å®¹ã€æ˜æ˜¾ä¸ç¬¦åˆéœ€æ±‚ï¼‰ï¼Œverdict=REQUEST_CHANGESï¼Œå¹¶æŠŠé—®é¢˜å†™åˆ° blockingã€‚
          - å¦‚æœæ²¡æœ‰é˜»å¡é¡¹ï¼Œverdict=APPROVEï¼Œblocking ä¸ºç©ºæ•°ç»„ã€‚
          - summary ç”¨ 1-3 æ¡æ¦‚æ‹¬æœ¬ PR åšäº†ä»€ä¹ˆã€‚
          - suggestions å¯ä»¥ç»™å¯é€‰æ”¹è¿›ï¼ˆä¸å¼ºåˆ¶ï¼‰ã€‚
          PROMPT

          # ç”¨ codex exec + output schema å¼ºåˆ¶äº§å‡ºæœºå™¨å¯è§£æç»“æœ
          codex \
            -c 'model_providers.custom_openai.name="Custom OpenAI"' \
            -c 'model_providers.custom_openai.base_url="${{ secrets.OPENAI_BASE_URL }}"' \
            -c 'model_providers.custom_openai.env_key="CUSTOM_OPENAI_KEY"' \
            -c 'model_provider="custom_openai"' \
            -a on-failure \
            exec \
            --sandbox read-only \
            --output-schema /tmp/review_schema.json \
            --output-last-message /tmp/review_out.json \
            -m gpt-5.3-codex \
            - < /tmp/review_prompt.txt

          python3 - <<'PY'
          import json
          from pathlib import Path

          data = json.loads(Path('/tmp/review_out.json').read_text('utf-8'))
          verdict = data['verdict']

          md = []
          md.append(f"VERDICT: {verdict}")
          md.append("")
          md.append("Summary:")
          for x in data['summary']:
            md.append(f"- {x}")
          md.append("")
          md.append("Blocking:")
          if data['blocking']:
            for x in data['blocking']:
              md.append(f"- {x}")
          else:
            md.append("- None")
          md.append("")
          md.append("Suggestions:")
          if data['suggestions']:
            for x in data['suggestions']:
              md.append(f"- {x}")
          else:
            md.append("- None")

          Path('/tmp/review.md').write_text("\n".join(md), encoding='utf-8')
          print(verdict)
          PY

          VERDICT=$(python3 -c 'import json; print(json.load(open("/tmp/review_out.json"))["verdict"])')
          echo "verdict=$VERDICT" >> $GITHUB_OUTPUT

          # é¿å…å¤šè¡Œ output åˆ†éš”ç¬¦å‘ï¼šæŠŠ review å†™åˆ°ä¸´æ—¶æ–‡ä»¶å¹¶è¾“å‡ºè·¯å¾„
          cp /tmp/review.md "$RUNNER_TEMP/review.md"
          echo "review_path=$RUNNER_TEMP/review.md" >> $GITHUB_OUTPUT

      - name: Submit PR review
        uses: actions/github-script@v7
        env:
          REVIEW_PATH: ${{ steps.codex.outputs.review_path }}
          VERDICT: ${{ steps.codex.outputs.verdict }}
        with:
          # ç”¨ä½ çš„ PAT æäº¤ reviewï¼Œè®© Review æ˜¾ç¤ºä¸º uf-hyï¼ˆPR ä½œè€…æ˜¯ GITHUB_TOKEN åˆ›å»ºçš„ botï¼Œä¸ä¼šæ’â€œè‡ªå·±å®¡è‡ªå·±â€ï¼‰
          github-token: ${{ secrets.PAT }}
          script: |
            const fs = require('fs');
            const pr = context.payload.pull_request;
            const verdict = (process.env.VERDICT || '').trim().toUpperCase();
            const reviewPath = process.env.REVIEW_PATH;
            const body = reviewPath && fs.existsSync(reviewPath)
              ? fs.readFileSync(reviewPath, 'utf8')
              : '(no review text)';

            const event = verdict === 'APPROVE' ? 'APPROVE' : 'REQUEST_CHANGES';

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              event,
              body,
            });

      - name: Notify Telegram (review result)
        continue-on-error: true
        env:
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
          VERDICT: ${{ steps.codex.outputs.verdict }}
          PR_NUM: ${{ github.event.pull_request.number }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          if [ -z "$TG_BOT_TOKEN" ] || [ -z "$TG_CHAT_ID" ]; then
            exit 0
          fi
          ISSUE_NUM=$(echo "$PR_BODY" | grep -oP 'Closes #\K\d+' | head -1)
          PR_URL="${{ github.server_url }}/${{ github.repository }}/pull/${PR_NUM}"
          if [ "$VERDICT" = "APPROVE" ]; then
            TITLE="âœ… [Revieweré€šè¿‡] PR #${PR_NUM}"
          else
            TITLE="ğŸ› ï¸ [Reviewerè¦æ±‚ä¿®æ”¹] PR #${PR_NUM}"
          fi
          TEXT="${TITLE}\n${PR_URL}\nIssue: #${ISSUE_NUM}"
          curl -fsS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage" \
            -d chat_id="$TG_CHAT_ID" \
            --data-urlencode text="$TEXT" \
            -d disable_web_page_preview=true >/dev/null || true

      - name: Send feedback back to Issue (max 5 rounds)
        if: ${{ steps.codex.outputs.verdict == 'REQUEST_CHANGES' }}
        uses: actions/github-script@v7
        env:
          REVIEW_PATH: ${{ steps.codex.outputs.review_path }}
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        with:
          # ç”¨ PAT è§¦å‘ issues:labeled å·¥ä½œæµï¼Œé¿å… GitHub é˜²é€’å½’æœºåˆ¶åäº‹ä»¶
          github-token: ${{ secrets.PAT }}
          script: |
            const fs = require('fs');
            const pr = context.payload.pull_request;
            const body = (pr.body || '');
            const m = body.match(/Closes\s+#(\d+)/i);
            if (!m) {
              core.warning('PR body has no Closes #<issue>, skip sending feedback');
              return;
            }
            const issue_number = Number(m[1]);

            const marker = '<!-- AI_PR_REVIEW_FEEDBACK -->';
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              per_page: 100,
            });
            const rounds = comments.filter(c => (c.body || '').includes(marker)).length;
            const nextRound = rounds + 1;

            if (nextRound > 5) {
              const stopMsg = `${marker}\nâš ï¸ PR Reviewer: å·²è¾¾åˆ°æœ€å¤§å›åˆæ•° 5ï¼Œåœæ­¢è‡ªåŠ¨å¾€è¿”ã€‚\nè¯·ä¸»äººæ‰‹åŠ¨ä»‹å…¥ï¼š${pr.html_url}`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number,
                body: stopMsg
              });

              // å…³é”®èŠ‚ç‚¹è¯¦ç»†é€šçŸ¥ï¼ˆè¶…è¿‡ 5 è½®ï¼‰
              const tgToken = process.env.TG_BOT_TOKEN || '';
              const tgChat = process.env.TG_CHAT_ID || '';
              if (tgToken && tgChat) {
                const tgText = [
                  'âš ï¸ [è‡ªåŠ¨æµç¨‹åœæ­¢ï¼šè¶…è¿‡5è½®]',
                  `PR #${pr.number}: ${pr.html_url}`,
                  `Issue #${issue_number}`,
                  'è¯·æ‰‹åŠ¨ä»‹å…¥å¤„ç†ã€‚'
                ].join('\n');
                await fetch(`https://api.telegram.org/bot${tgToken}/sendMessage`, {
                  method: 'POST',
                  headers: {'content-type': 'application/x-www-form-urlencoded'},
                  body: new URLSearchParams({chat_id: tgChat, text: tgText, disable_web_page_preview: 'true'})
                });
              }
              return;
            }

            const reviewPath = process.env.REVIEW_PATH;
            const reviewText = reviewPath && fs.existsSync(reviewPath)
              ? fs.readFileSync(reviewPath, 'utf8')
              : '(no review text)';

            const commentBody = [
              marker,
              `### ğŸ” PR Reviewer åé¦ˆï¼ˆç¬¬ ${nextRound}/5 è½®ï¼‰`,
              `æ¥æº PR: #${pr.number} ${pr.html_url}`,
              '',
              reviewText,
              '',
              'è¯· Issue Handler æ ¹æ®ä»¥ä¸Š Blocking/Suggestions ä¿®å¤åå†æ¨æ–°æäº¤ã€‚'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              body: commentBody,
            });

            // é‡æ–°è§¦å‘ Issue handlerï¼štoggle auto-work label
            const labels = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              per_page: 100,
            });
            const has = labels.data.some(l => l.name === 'auto-work');
            if (has) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number,
                name: 'auto-work',
              });
            }
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              labels: ['auto-work'],
            });
